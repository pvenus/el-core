"""Scenario system: round-based dialogue/choices driven by emotion state.

You said:
- You will author/manage scenarios where, each round, the agent chooses one of several replies.
- The set of replies (choices) differs per round.
- The goal is to select the most appropriate reply based on the agent's emotion state.
- Later, scenarios will be generated by tools; therefore JSON import/export should be supported.

Design
------
This module is intentionally independent from the ontology/reasoner layer.
- A Scenario provides *textual* choices per round.
- Each Choice carries tags/effects and optional action payloads; vector movement is derived from action payloads elsewhere.
- Selection is done by:
    1) receive allowed/preferred tags (e.g., from ontology layer)
    2) filter choices whose tags intersect those tags
    3) optionally apply simple constraints

You can later plug in:
- ontology masking (allowed actions)
- reasoner explanations
- RL policy selection
- vector similarity ranking (optional, currently disabled by default)

"""

from __future__ import annotations

from src.scenario.dto import SelectionContext
from src.scenario import build_demo_scenario
from src.scenario import ScenarioSession

if __name__ == "__main__":
    mgr = build_demo_scenario(dim=6)

    # Example emotion state with tag filtering
    ctx = SelectionContext(
        turn=1,
        current_vec=[0.10, 0.05, 0.15, 0.05, 0.10, 0.05],
        comfort_vec=[-0.10, 0.20, -0.05, 0.25, 0.05, -0.05],
        allowed_tags=["comforting"],
    )

    print(mgr.to_json())
    print("\nRound 1 ranked:")
    for item in mgr.rank_choices(1, ctx, top_k=3):
        print(f"- {item['choice_id']} score={item['score']:.3f} tags={item['tags']} :: {item['display_text']}")

    choice = mgr.select_choice(1, ctx)
    print("\nSelected for round 1:")
    print(choice.choice_id, choice.display_text)

    print("\n--- Session demo (sequential, choice affects state) ---")
    session = ScenarioSession(mgr, init_round_id=1, ctx=ctx)

    # Show available choices for round 1
    for item in session.get_round_choices(top_k=6):
        print(f"[R1 option] {item['choice_id']} :: {item['display_text']}")

    # Take an explicit choice, then continue to next round regardless
    step1 = session.step(choice_id="r1_c")
    print("Step1:", step1["choice_id"], step1["display_text"])
    print("memory_tags:", step1["memory_tags"], "current_vec:", step1["current_vec"])

    # Auto-select next round using updated memory_tags/current_vec
    step2 = session.step()
    print("Step2:", step2["choice_id"], step2["display_text"])