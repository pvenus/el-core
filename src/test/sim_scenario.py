"""Scenario system: round-based dialogue/choices driven by emotion state.

You said:
- You will author/manage scenarios where, each round, the agent chooses one of several replies.
- The set of replies (choices) differs per round.
- The goal is to select the most appropriate reply based on the agent's emotion state.
- Later, scenarios will be generated by tools; therefore JSON import/export should be supported.

Design
------
This module is intentionally independent from the ontology/reasoner layer.
- A Scenario provides *textual* choices per round.
- Each Choice carries tags/effects and optional action payloads; vector movement is derived from action payloads elsewhere.
- Selection is done by:
    1) receive allowed/preferred tags (e.g., from ontology layer)
    2) filter choices whose tags intersect those tags
    3) optionally apply simple constraints

You can later plug in:
- ontology masking (allowed actions)
- reasoner explanations
- RL policy selection
- vector similarity ranking (optional, currently disabled by default)

"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

import json


# -----------------------------
# Minimal vector helpers
# -----------------------------

def _dot(a: Sequence[float], b: Sequence[float]) -> float:
    return sum(float(x) * float(y) for x, y in zip(a, b))


def _norm(a: Sequence[float]) -> float:
    return _dot(a, a) ** 0.5


def normalize(v: Sequence[float], eps: float = 1e-12) -> List[float]:
    n = _norm(v)
    if n < eps:
        return [0.0 for _ in v]
    return [float(x) / n for x in v]


def l2_distance(a: Sequence[float], b: Sequence[float]) -> float:
    return sum((float(x) - float(y)) ** 2 for x, y in zip(a, b)) ** 0.5


# -----------------------------
# Scenario data model
# -----------------------------

@dataclass(frozen=True)
class Choice:
    """One candidate reply the agent can say.

    Fields
    ------
    - choice_id: stable id for tools/content pipelines
    - display_text: text shown to the user
    - tags: optional labels (e.g., "comforting", "avoidant", "provoking")
    - constraints: lightweight rule slots for future use. This module only supports:
        * min_turn, max_turn (inclusive)
        * min_dist_to_comfort, max_dist_to_comfort
      Everything else is preserved for external evaluators.
    - effects: optional dict of effects to apply if this choice is selected
    - action: optional dict payload for EventRecord bridging (embed_text, duration, magnitude, embed_vec); embed_text lives here
    """

    choice_id: str
    display_text: str
    tags: Tuple[str, ...] = ()
    constraints: Dict[str, Any] = field(default_factory=dict)
    effects: Dict[str, Any] = field(default_factory=dict)
    action: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def create(
        choice_id: str,
        display_text: str,
        tags: Optional[Sequence[str]] = None,
        constraints: Optional[Dict[str, Any]] = None,
        effects: Optional[Dict[str, Any]] = None,
        action: Optional[Dict[str, Any]] = None,
    ) -> "Choice":
        act = dict(action or {})
        # If caller didn't provide action.embed_text, default to display_text.
        if "embed_text" not in act or not act.get("embed_text"):
            act["embed_text"] = str(display_text)

        return Choice(
            choice_id=str(choice_id),
            display_text=str(display_text),
            tags=tuple(tags or ()),
            constraints=dict(constraints or {}),
            effects=dict(effects or {}),
            action=act,
        )


@dataclass
class RoundSpec:
    """A single round containing multiple agent reply choices."""

    round_id: int
    choices: List[Choice] = field(default_factory=list)

    def add_choice(self, choice: Choice) -> None:
        self.choices.append(choice)


@dataclass
class Scenario:
    """A full scenario: ordered rounds."""

    scenario_id: str
    title: str = ""
    dim: int = 6
    rounds: List[RoundSpec] = field(default_factory=list)

    def get_round(self, round_id: int) -> RoundSpec:
        for r in self.rounds:
            if r.round_id == int(round_id):
                return r
        raise KeyError(f"round_id not found: {round_id}")

    def add_round(self, round_spec: RoundSpec) -> None:
        self.rounds.append(round_spec)
        self.rounds.sort(key=lambda x: x.round_id)


# -----------------------------
# Selection engine
# -----------------------------

@dataclass
class SelectionContext:
    """Inputs for selecting a choice."""

    turn: int
    current_vec: Sequence[float]
    comfort_vec: Sequence[float]
    allowed_tags: Optional[Sequence[str]] = None


# --- Sequential session runner (non-branching) ---

@dataclass
class SessionState:
    """Mutable session state so dialogue can continue regardless of which choice was taken."""

    round_id: int
    turn: int
    current_vec: List[float]
    comfort_vec: List[float]
    memory_tags: List[str] = field(default_factory=list)
    history: List[Dict[str, Any]] = field(default_factory=list)


class ScenarioSession:
    """Runs a scenario sequentially (no branching), while choices can still affect state.

    This satisfies:
      - Any choice in a round continues to the next round.
      - Choices can optionally modify emotion vector / tags via `Choice.effects`.

    Supported effect keys (all optional):
      - delta_vec: list[float]  -> added to current_vec
      - add_tags: list[str]     -> appended to memory_tags (unique, lowercase)
      - remove_tags: list[str]  -> removed from memory_tags
    """

    def __init__(self, manager: "ScenarioManager", init_round_id: int, ctx: SelectionContext):
        self.manager = manager
        self.state = SessionState(
            round_id=int(init_round_id),
            turn=int(ctx.turn),
            current_vec=[float(x) for x in ctx.current_vec],
            comfort_vec=[float(x) for x in ctx.comfort_vec],
            memory_tags=[t.strip().lower() for t in (ctx.allowed_tags or []) if t and t.strip()],
            history=[],
        )

    def _apply_effects(self, choice: Choice) -> None:
        eff = choice.effects or {}

        # Vector update
        delta = eff.get("delta_vec")
        if isinstance(delta, list) and delta:
            for i in range(min(len(self.state.current_vec), len(delta))):
                self.state.current_vec[i] = float(self.state.current_vec[i]) + float(delta[i])

        # Tag memory update
        add_tags = eff.get("add_tags")
        if isinstance(add_tags, list):
            for t in add_tags:
                if not t:
                    continue
                tt = str(t).strip().lower()
                if tt and tt not in self.state.memory_tags:
                    self.state.memory_tags.append(tt)

        remove_tags = eff.get("remove_tags")
        if isinstance(remove_tags, list):
            rm = {str(t).strip().lower() for t in remove_tags if t and str(t).strip()}
            if rm:
                self.state.memory_tags = [t for t in self.state.memory_tags if t not in rm]

    def get_round_choices(self, top_k: int = 6) -> List[Dict[str, Any]]:
        ctx = SelectionContext(
            turn=self.state.turn,
            current_vec=self.state.current_vec,
            comfort_vec=self.state.comfort_vec,
            allowed_tags=self.state.memory_tags,
        )
        return self.manager.rank_choices(self.state.round_id, ctx, top_k=top_k)

    def step(self, choice_id: Optional[str] = None) -> Dict[str, Any]:
        """Advance one round.

        If choice_id is None, the manager will select the top-ranked choice.
        Returns a tool-friendly dict containing chosen line + next state.
        """
        ctx = SelectionContext(
            turn=self.state.turn,
            current_vec=self.state.current_vec,
            comfort_vec=self.state.comfort_vec,
            allowed_tags=self.state.memory_tags,
        )

        r = self.manager.scenario.get_round(self.state.round_id)

        chosen: Optional[Choice] = None
        if choice_id is not None:
            for c in r.choices:
                if c.choice_id == choice_id:
                    chosen = c
                    break
        if chosen is None:
            chosen = self.manager.select_choice(self.state.round_id, ctx)

        # Apply effects so conversation continues with updated state
        self._apply_effects(chosen)

        record = {
            "round_id": int(self.state.round_id),
            "choice_id": chosen.choice_id,
            "display_text": chosen.display_text,
            "tags": list(chosen.tags),
            "effects": dict(chosen.effects),
            "action": dict(chosen.action),
            "turn": int(self.state.turn),
            "current_vec": list(self.state.current_vec),
            "memory_tags": list(self.state.memory_tags),
        }
        self.state.history.append(record)

        # Sequential progression: next round regardless of choice
        next_round_id = self.state.round_id + 1
        has_next = any(rr.round_id == next_round_id for rr in self.manager.scenario.rounds)
        self.state.round_id = next_round_id if has_next else self.state.round_id
        self.state.turn += 1

        record["next_round_id"] = int(self.state.round_id) if has_next else None
        record["has_next"] = bool(has_next)
        return record


class ScenarioManager:
    """Manages scenarios and selects choices per round."""

    def __init__(self, scenario: Scenario):
        self.scenario = scenario

    # ---- IO (tool-friendly) ----

    def to_dict(self) -> Dict[str, Any]:
        s = self.scenario
        return {
            "scenario_id": s.scenario_id,
            "title": s.title,
            "dim": int(s.dim),
            "rounds": [
                {
                    "round_id": int(r.round_id),
                    "choices": [
                        {
                            "choice_id": c.choice_id,
                            "display_text": c.display_text,
                            "tags": list(c.tags),
                            "constraints": dict(c.constraints),
                            "effects": dict(c.effects),
                            "action": dict(c.action),
                        }
                        for c in r.choices
                    ],
                }
                for r in s.rounds
            ],
        }

    def to_json(self, ensure_ascii: bool = False, indent: int = 2) -> str:
        return json.dumps(self.to_dict(), ensure_ascii=ensure_ascii, indent=indent)

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ScenarioManager":
        scenario = Scenario(
            scenario_id=str(d.get("scenario_id", "scenario")),
            title=str(d.get("title", "")),
            dim=int(d.get("dim", 6)),
        )

        for r in d.get("rounds", []):
            rs = RoundSpec(round_id=int(r["round_id"]))
            for c in r.get("choices", []):
                display_text = c.get("display_text", c.get("text", ""))
                action = c.get("action", None)
                if not action:
                    # Backward compatibility: if legacy embed_text exists, store it in action.embed_text.
                    legacy_embed = c.get("embed_text", display_text)
                    action = {"embed_text": legacy_embed}
                elif isinstance(action, dict) and ("embed_text" not in action or not action.get("embed_text")):
                    action = dict(action)
                    action["embed_text"] = c.get("embed_text", display_text)
                rs.add_choice(
                    Choice.create(
                        choice_id=str(c["choice_id"]),
                        display_text=display_text,
                        tags=c.get("tags", None),
                        constraints=c.get("constraints", None),
                        effects=c.get("effects", None),
                        action=action,
                    )
                )
            scenario.add_round(rs)

        return ScenarioManager(scenario)

    @staticmethod
    def from_json(s: str) -> "ScenarioManager":
        return ScenarioManager.from_dict(json.loads(s))

    # ---- core selection ----

    def normalize_tags(self, tags: Optional[Sequence[str]]) -> List[str]:
        if tags is None:
            return []
        return [t.strip().lower() for t in tags if t and t.strip()]

    def tags_match(self, choice: Choice, allowed_tags: Sequence[str]) -> bool:
        if not allowed_tags:
            return True
        choice_tags = set(t.lower() for t in choice.tags)
        allowed_set = set(allowed_tags)
        return bool(choice_tags.intersection(allowed_set))

    def _passes_constraints(self, choice: Choice, ctx: SelectionContext) -> bool:
        """Very small built-in constraint subset.

        Supported keys in choice.constraints:
          - min_turn, max_turn (inclusive)
          - min_dist_to_comfort, max_dist_to_comfort

        Other keys are ignored here (kept for external evaluators/reasoners).
        """
        cons = choice.constraints or {}
        t = int(ctx.turn)

        if "min_turn" in cons and t < int(cons["min_turn"]):
            return False
        if "max_turn" in cons and t > int(cons["max_turn"]):
            return False

        dist = l2_distance(ctx.current_vec, ctx.comfort_vec)
        if "min_dist_to_comfort" in cons and dist < float(cons["min_dist_to_comfort"]):
            return False
        if "max_dist_to_comfort" in cons and dist > float(cons["max_dist_to_comfort"]):
            return False

        return True

    def rank_choices(
        self,
        round_id: int,
        ctx: SelectionContext,
        top_k: int = 3,
        min_similarity: float = -1.0,
    ) -> List[Dict[str, Any]]:
        """Return ranked choices for a round.

        Scoring:
          - Tag-based filtering and scoring by number of matched tags.
          - If allowed_tags empty: all choices included with score=0.
          - Otherwise, only choices matching allowed_tags are included.

        Returns tool-friendly dict entries with score.
        """
        r = self.scenario.get_round(round_id)
        allowed_tags = self.normalize_tags(ctx.allowed_tags)

        candidates: List[Choice] = []
        for c in r.choices:
            if not self._passes_constraints(c, ctx):
                continue
            candidates.append(c)

        def _score(choice: Choice) -> int:
            if not allowed_tags:
                return 0
            c_tags_lower = set(t.lower() for t in choice.tags)
            return len(c_tags_lower.intersection(set(allowed_tags)))

        # First pass: if allowed_tags provided, try strict tag matching
        scored: List[Tuple[int, Choice]] = []
        if allowed_tags:
            for c in candidates:
                if not self.tags_match(c, allowed_tags):
                    continue
                scored.append((_score(c), c))

            # Graceful fallback: if nothing matched, return all candidates with score=0
            if not scored:
                scored = [(0, c) for c in candidates]
        else:
            scored = [(0, c) for c in candidates]

        scored.sort(key=lambda x: (-x[0], x[1].choice_id))
        out: List[Dict[str, Any]] = []
        for score, c in scored[: int(top_k)]:
            out.append(
                {
                    "choice_id": c.choice_id,
                    "display_text": c.display_text,
                    "score": float(score),
                    "tags": list(c.tags),
                    "constraints": dict(c.constraints),
                    "action": dict(c.action),
                }
            )
        return out

    def select_choice(self, round_id: int, ctx: SelectionContext) -> Choice:
        ranked = self.rank_choices(round_id, ctx, top_k=1)
        if not ranked:
            # fallback: first choice, even if unscored
            r = self.scenario.get_round(round_id)
            if not r.choices:
                raise ValueError(f"Round {round_id} has no choices")
            return r.choices[0]

        top_id = ranked[0]["choice_id"]
        r = self.scenario.get_round(round_id)
        for c in r.choices:
            if c.choice_id == top_id:
                return c
        return r.choices[0]


# -----------------------------
# Demo
# -----------------------------

def build_demo_scenario(dim: int = 6) -> ScenarioManager:
    s = Scenario(scenario_id="demo", title="Demo Scenario", dim=dim)

    r1 = RoundSpec(round_id=1)
    r1.add_choice(
        Choice.create(
            choice_id="r1_a",
            display_text="I'm here with you. Let's take a breath together. (나는 네 곁에 있어. 같이 숨 쉬자.)",
            tags=["comforting", "grounding"],
            effects={"delta_vec": [-0.03, 0.05, -0.01, 0.02, 0.01, -0.01][:dim], "add_tags": ["comforting"]},
            action={"action_id": "breath", "embed_text": "I'm here with you. Let's take a breath together.", "duration": 1, "magnitude": 0.25, "embed_vec": [0.12, -0.08, 0.05, 0.02, -0.04, 0.09][:dim]},
        )
    )
    r1.add_choice(
        Choice.create(
            choice_id="r1_b",
            display_text="Tell me what happened—start anywhere. (무슨 일이 있었는지 말해줘. 어디서부터든 좋아.)",
            tags=["listening", "support"],
            effects={"add_tags": ["listening"]},
            action={"action_id": "reach_out", "embed_text": "Tell me what happened. Start anywhere.", "duration": 1, "magnitude": 0.20, "embed_vec": [0.05, 0.10, -0.02, 0.07, 0.01, -0.03][:dim]},
        )
    )
    r1.add_choice(
        Choice.create(
            choice_id="r1_c",
            display_text="Let's step back for a moment and name the feeling. (잠깐 물러서서 감정을 이름 붙여보자.)",
            tags=["reframe", "reflect"],
            effects={"add_tags": ["reframe"]},
            action={"action_id": "plan", "embed_text": "Step back and name the feeling.", "duration": 1, "magnitude": 0.30, "embed_vec": [-0.01, 0.08, 0.11, -0.04, 0.06, 0.02][:dim]},
        )
    )
    r1.add_choice(
        Choice.create(
            choice_id="r1_d",
            display_text="Do you want advice, or just someone to listen? (조언이 필요해, 아니면 그냥 들어줄까?)",
            tags=["clarify", "respect"],
            effects={"add_tags": ["clarify"]},
            action={"action_id": "reach_out", "embed_text": "Do you want advice or listening?", "duration": 1, "magnitude": 0.15, "embed_vec": [0.03, 0.04, 0.01, 0.05, -0.02, 0.00][:dim]},
        )
    )
    r1.add_choice(
        Choice.create(
            choice_id="r1_e",
            display_text="Whatever. It's not a big deal. (뭐 어때. 별일 아니잖아.)",
            tags=["dismissive", "avoidant"],
            effects={"delta_vec": [0.04, -0.03, 0.05, 0.02, -0.06, 0.01][:dim], "add_tags": ["avoidant"]},
            action={"action_id": "avoid", "embed_text": "Dismiss the situation.", "duration": 2, "magnitude": 0.45, "embed_vec": [0.18, -0.12, 0.09, 0.06, -0.10, 0.04][:dim]},
        )
    )
    s.add_round(r1)

    r2 = RoundSpec(round_id=2)
    r2.add_choice(
        Choice.create(
            choice_id="r2_a",
            display_text="Let's turn this into one small step you can do now. (지금 당장 할 수 있는 작은 한 걸음으로 바꿔보자.)",
            tags=["coach", "plan"],
            effects={"add_tags": ["coach"]},
            action={"action_id": "plan", "embed_text": "Turn this into one small step now.", "duration": 1, "magnitude": 0.35, "embed_vec": [0.06, 0.02, 0.10, -0.03, 0.08, 0.01][:dim]},
        )
    )
    r2.add_choice(
        Choice.create(
            choice_id="r2_b",
            display_text="Say it all—no filter. I'll take it. (필터 없이 다 말해. 내가 받아줄게.)",
            tags=["vent", "impulsive"],
            constraints={"min_dist_to_comfort": 0.2},
            effects={"add_tags": ["vent"], "delta_vec": [0.05, 0.01, -0.03, 0.02, -0.01, 0.0][:dim]},
            action={"action_id": "vent", "embed_text": "Say it all, no filter.", "duration": 2, "magnitude": 0.85, "embed_vec": [0.22, -0.15, -0.05, 0.12, -0.08, 0.03][:dim]},
        )
    )
    r2.add_choice(
        Choice.create(
            choice_id="r2_c",
            display_text="We can pause and come back later. You're allowed to rest. (잠깐 멈췄다가 나중에 다시 해도 돼. 쉬어도 돼.)",
            tags=["comforting", "rest"],
            effects={"delta_vec": [-0.03, 0.04, -0.01, 0.03, 0.01, -0.01][:dim], "add_tags": ["comforting"]},
            action={"action_id": "avoid", "embed_text": "Pause and come back later.", "duration": 2, "magnitude": 0.40, "embed_vec": [-0.09, 0.14, -0.04, 0.10, 0.05, -0.02][:dim]},
        )
    )
    r2.add_choice(
        Choice.create(
            choice_id="r2_d",
            display_text="What do you need most right now: safety, fairness, or control? (지금 가장 필요한 건 안전, 공정함, 통제 중 뭐야?)",
            tags=["probe", "reflect"],
            effects={"add_tags": ["reflect"]},
            action={"action_id": "plan", "embed_text": "Need safety, fairness, or control?", "duration": 1, "magnitude": 0.25, "embed_vec": [0.02, 0.09, 0.04, -0.01, 0.07, 0.02][:dim]},
        )
    )
    r2.add_choice(
        Choice.create(
            choice_id="r2_e",
            display_text="Walk away. You don't have to deal with this right now. (떠나자. 지금 당장 감당할 필요 없어.)",
            tags=["avoidant"],
            effects={"add_tags": ["avoidant"]},
            action={"action_id": "avoid", "embed_text": "Walk away for now.", "duration": 2, "magnitude": 0.55, "embed_vec": [0.16, -0.10, 0.07, 0.05, -0.06, 0.01][:dim]},
        )
    )
    s.add_round(r2)

    r3 = RoundSpec(round_id=3)
    r3.add_choice(
        Choice.create(
            choice_id="r3_a",
            display_text="We can take it slowly. You're safe right now. (천천히 해도 돼. 지금은 안전해.)",
            tags=["comforting", "reassurance"],
            effects={"delta_vec": [-0.02, 0.03, -0.01, 0.02, 0.01, -0.01][:dim]},
            action={"action_id": "breath", "embed_text": "Take it slowly. You're safe.", "duration": 1, "magnitude": 0.30, "embed_vec": [-0.07, 0.12, -0.03, 0.08, 0.04, -0.01][:dim]},
        )
    )
    r3.add_choice(
        Choice.create(
            choice_id="r3_b",
            display_text="Let's name the fear and pick one tiny action. (두려움을 이름 붙이고 아주 작은 행동 하나만 고르자.)",
            tags=["coach", "reframe"],
            effects={"add_tags": ["coach", "reframe"]},
            action={"action_id": "plan", "embed_text": "Name the fear and pick one tiny action.", "duration": 1, "magnitude": 0.50, "embed_vec": [0.08, 0.05, 0.11, -0.04, 0.09, 0.03][:dim]},
        )
    )
    r3.add_choice(
        Choice.create(
            choice_id="r3_c",
            display_text="If it's too much, we can park it for tonight. (너무 힘들면 오늘은 잠깐 접어두자.)",
            tags=["rest", "boundary"],
            effects={"add_tags": ["rest"]},
            action={"action_id": "avoid", "embed_text": "Park it for tonight.", "duration": 2, "magnitude": 0.35, "embed_vec": [-0.10, 0.09, -0.02, 0.07, 0.06, -0.03][:dim]},
        )
    )
    r3.add_choice(
        Choice.create(
            choice_id="r3_d",
            display_text="I can be blunt if you want—what's the hardest truth here? (원하면 직설적으로 말할게. 여기서 가장 힘든 진실은 뭐야?)",
            tags=["direct", "probe"],
            effects={"add_tags": ["direct"]},
            action={"action_id": "vent", "embed_text": "What's the hardest truth here?", "duration": 1, "magnitude": 0.40, "embed_vec": [0.12, 0.00, 0.06, -0.02, 0.05, 0.01][:dim]},
        )
    )
    r3.add_choice(
        Choice.create(
            choice_id="r3_e",
            display_text="Let's write two lines: what you can control, and what you can't. (두 줄로 적자: 통제 가능한 것 / 불가능한 것.)",
            tags=["reframe", "plan"],
            effects={"add_tags": ["plan", "reframe"]},
            action={"action_id": "plan", "embed_text": "Write what you can control vs can't.", "duration": 1, "magnitude": 0.30, "embed_vec": [0.05, 0.07, 0.09, -0.03, 0.08, 0.02][:dim]},
        )
    )
    s.add_round(r3)

    return ScenarioManager(s)


if __name__ == "__main__":
    mgr = build_demo_scenario(dim=6)

    # Example emotion state with tag filtering
    ctx = SelectionContext(
        turn=1,
        current_vec=[0.10, 0.05, 0.15, 0.05, 0.10, 0.05],
        comfort_vec=[-0.10, 0.20, -0.05, 0.25, 0.05, -0.05],
        allowed_tags=["comforting"],
    )

    print(mgr.to_json())
    print("\nRound 1 ranked:")
    for item in mgr.rank_choices(1, ctx, top_k=3):
        print(f"- {item['choice_id']} score={item['score']:.3f} tags={item['tags']} :: {item['display_text']}")

    choice = mgr.select_choice(1, ctx)
    print("\nSelected for round 1:")
    print(choice.choice_id, choice.display_text)

    print("\n--- Session demo (sequential, choice affects state) ---")
    session = ScenarioSession(mgr, init_round_id=1, ctx=ctx)

    # Show available choices for round 1
    for item in session.get_round_choices(top_k=6):
        print(f"[R1 option] {item['choice_id']} :: {item['display_text']}")

    # Take an explicit choice, then continue to next round regardless
    step1 = session.step(choice_id="r1_c")
    print("Step1:", step1["choice_id"], step1["display_text"])
    print("memory_tags:", step1["memory_tags"], "current_vec:", step1["current_vec"])

    # Auto-select next round using updated memory_tags/current_vec
    step2 = session.step()
    print("Step2:", step2["choice_id"], step2["display_text"])