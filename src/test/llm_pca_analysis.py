

import json
import os
import csv
from typing import Dict, List, Tuple

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401  (needed for 3D plots)
from sklearn.decomposition import PCA


# Path to the embedding JSON generated by llm_emb_list.py
EMBEDDING_PATH = "data/embeddings/emotion_words_llama3.2-1b.json"
OUT_DIR = "data/embeddings/pca"


# === 1. Category definitions (must stay in sync with WORDS in llm_emb_list.py) ===
POSITIVE = [
    "joy", "happiness", "delight", "pleasure", "love", "affection", "calm", "relief",
    "hope", "gratitude", "pride", "excitement", "enthusiasm", "amusement", "serenity",
    "satisfaction", "compassion", "trust", "admiration", "inspiration", "optimism",
    "confidence", "contentment", "friendship", "warmth", "kindness", "sympathy",
    "tenderness", "euphoria", "bliss", "cheerfulness", "radiance", "comfort",
    "encouragement", "supportiveness", "bravery", "courage", "self_love", "clarity",
]

NEGATIVE = [
    "sadness", "grief", "sorrow", "despair", "depression", "loneliness", "remorse",
    "bitterness", "jealousy", "envy", "insecurity", "shame", "guilt", "humiliation",
    "boredom", "regret", "loss", "trauma", "shock", "abandonment", "isolation",
    "hopelessness", "melancholy", "emptiness", "misery", "resentment", "self_doubt",
    "worthlessness", "fatigue", "pain", "brokenness", "vulnerability", "heartbreak",
]

ANGER = [
    "anger", "rage", "irritation", "frustration", "resentment", "fury", "hostility",
    "annoyance", "indignation", "violence", "aggression", "wrath", "displeasure",
    "outrage", "offense", "provocation", "grudge", "hatred", "conflict",
]

FEAR = [
    "fear", "terror", "panic", "anxiety", "worry", "dread", "nervousness",
    "suspicion", "paranoia", "vulnerability", "helplessness", "phobia",
    "horror", "tension", "alertness", "unease", "startle", "timidity",
    "hesitation", "apprehension",
]

DISGUST = [
    "disgust", "aversion", "contempt", "revulsion", "rejection", "distaste",
    "loathing", "abhorrence", "disdain", "nausea",
]

SURPRISE = [
    "surprise", "astonishment", "confusion", "disbelief", "amazement",
    "wonder", "curiosity", "intrigue", "shock_reaction", "uncertainty",
]

COGNITIVE = [
    "anticipation", "curiosity", "nostalgia", "uncertainty", "focus",
    "determination", "ambition", "motivation", "drive", "persistence",
    "critical_thinking", "reflection", "awareness", "perception",
    "intuition", "insight", "vigilance", "planning", "expectation",
    "prediction",
]

SURVIVAL = [
    "danger", "threat", "injury", "harm", "safety", "protection", "survival",
    "risk", "alert", "emergency", "failure", "collapse", "rescue", "escape",
    "fearlessness", "endurance", "resilience", "scarcity", "pressure", "burden",
]

SOCIAL = [
    "success", "failure", "ambition", "determination", "exhaustion",
    "responsibility", "duty", "justice", "injustice", "leadership",
    "competition", "cooperation", "conflict", "betrayal", "loyalty",
    "support", "reconciliation", "dominance", "submission", "dependence",
    "freedom", "oppression", "authority", "rebellion", "obedience",
    "hierarchy", "unity", "division", "trustworthiness", "reliability",
    "influence", "prestige", "reputation", "identity", "connection",
]

LIFE_EVENTS = [
    "birth", "death", "illness", "recovery", "separation", "reunion",
    "transformation", "growth", "learning", "awakening", "ending", "beginning",
    "transition", "renewal", "decline", "healing", "injury_event",
    "celebration", "tragedy", "sacrifice",
]

TRAITS = [
    "introversion", "extroversion", "sensitivity", "stability", "chaos",
    "order", "discipline", "impulsiveness", "kindheartedness", "creativity",
    "logic", "rationality", "emotion", "stubbornness", "flexibility",
    "honesty", "deceit", "bravery_trait", "fearfulness", "dominance_trait",
]

EXTRA = [
    "embarassment", "uneasiness", "admiration_deep", "longing", "yearning",
    "comforting", "soothing", "insecurity_deep", "self_blame", "pressure_high",
    "relaxation", "emptiness_deep", "compassion_deep", "affection_warm",
    "devotion", "attachment", "care", "pleading", "appeal", "submission_emotional",
]


def build_category_map() -> Dict[str, str]:
    """Create a word -> category mapping from the lists above."""

    mapping: Dict[str, str] = {}

    for w in POSITIVE:
        mapping[w] = "positive"
    for w in NEGATIVE:
        mapping[w] = "negative"
    for w in ANGER:
        mapping[w] = "anger"
    for w in FEAR:
        mapping[w] = "fear"
    for w in DISGUST:
        mapping[w] = "disgust"
    for w in SURPRISE:
        mapping[w] = "surprise"
    for w in COGNITIVE:
        mapping[w] = "cognitive"
    for w in SURVIVAL:
        mapping[w] = "survival"
    for w in SOCIAL:
        mapping[w] = "social"
    for w in LIFE_EVENTS:
        mapping[w] = "life_event"
    for w in TRAITS:
        mapping[w] = "trait"
    for w in EXTRA:
        mapping[w] = "extra"

    return mapping


def load_embeddings(path: str) -> Tuple[List[str], np.ndarray]:
    """Load embeddings from JSON.

    Expected format (from llm_emb_list.py):

    {
        "embeddings": {
            "word": {"pooled": [.. float ..], ...},
            ...
        },
        ...
    }
    """

    if not os.path.exists(path):
        raise FileNotFoundError(f"Embedding file not found: {path}")

    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)

    if "embeddings" in data:
        items = data["embeddings"].items()
    else:
        # Fallback: assume top-level is {word: vector or {"pooled": vector}}
        items = data.items()

    words: List[str] = []
    vectors: List[List[float]] = []

    for word, info in items:
        if isinstance(info, dict):
            if "pooled" in info:
                vec = info["pooled"]
            elif "embedding" in info:
                vec = info["embedding"]
            else:
                continue
        else:
            # info is directly the vector
            vec = info

        words.append(word)
        vectors.append(vec)

    if not words:
        raise ValueError("No embeddings found in JSON file")

    arr = np.asarray(vectors, dtype=np.float32)
    return words, arr


def ensure_out_dir() -> None:
    os.makedirs(OUT_DIR, exist_ok=True)


def save_overall_pca(words: List[str], X: np.ndarray, categories: Dict[str, str]) -> None:
    """Compute PCA on all embeddings and save CSV + scatter plot."""

    print("[PCA] Fitting overall PCA (n_components=2) on", len(words), "words")
    pca = PCA(n_components=2)
    coords = pca.fit_transform(X)

    cat_list = [categories.get(w, "unknown") for w in words]

    # Save CSV
    csv_path = os.path.join(OUT_DIR, "emotion_pca_overall.csv")
    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["word", "category", "pc1", "pc2"])
        for w, c, (x, y) in zip(words, cat_list, coords):
            writer.writerow([w, c, float(x), float(y)])

    print(f"[PCA] Saved overall PCA CSV -> {csv_path}")

    # Scatter plot with category colors
    unique_cats = sorted(set(cat_list))
    palette = [
        "tab:blue", "tab:orange", "tab:green", "tab:red", "tab:purple",
        "tab:brown", "tab:pink", "tab:gray", "tab:olive", "tab:cyan",
    ]
    color_map = {cat: palette[i % len(palette)] for i, cat in enumerate(unique_cats)}

    plt.figure(figsize=(11, 9))
    for w, c, (x, y) in zip(words, cat_list, coords):
        plt.scatter(x, y, s=20, color=color_map.get(c, "black"), alpha=0.8)
        plt.text(x + 0.02, y + 0.02, w, fontsize=6, alpha=0.9)

    plt.title("Emotion Embeddings PCA (overall)")
    plt.xlabel("PC1")
    plt.ylabel("PC2")

    # build legend
    handles = []
    for cat in unique_cats:
        handles.append(plt.Line2D([0], [0], marker="o", color="w",
                                  markerfacecolor=color_map[cat], label=cat, markersize=8))
    plt.legend(handles=handles, fontsize=8, loc="best")

    plt.tight_layout()
    png_path = os.path.join(OUT_DIR, "emotion_pca_overall.png")
    plt.savefig(png_path, dpi=200)
    plt.close()

    print(f"[PCA] Saved overall PCA plot -> {png_path}")


def save_overall_pca_3d(words: List[str], X: np.ndarray, categories: Dict[str, str]) -> None:
    """Compute PCA (3D) on all embeddings and save CSV + 3D scatter plot."""

    print("[PCA-3D] Fitting overall PCA (n_components=3) on", len(words), "words")
    pca = PCA(n_components=3)
    coords = pca.fit_transform(X)

    cat_list = [categories.get(w, "unknown") for w in words]

    # Save CSV
    csv_path = os.path.join(OUT_DIR, "emotion_pca_overall_3d.csv")
    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["word", "category", "pc1", "pc2", "pc3"])
        for w, c, (x, y, z) in zip(words, cat_list, coords):
            writer.writerow([w, c, float(x), float(y), float(z)])

    print(f"[PCA-3D] Saved overall PCA CSV -> {csv_path}")

    # 3D scatter plot with category colors
    unique_cats = sorted(set(cat_list))
    palette = [
        "tab:blue", "tab:orange", "tab:green", "tab:red", "tab:purple",
        "tab:brown", "tab:pink", "tab:gray", "tab:olive", "tab:cyan",
    ]
    color_map = {cat: palette[i % len(palette)] for i, cat in enumerate(unique_cats)}

    fig = plt.figure(figsize=(11, 9))
    ax = fig.add_subplot(111, projection="3d")

    for w, c, (x, y, z) in zip(words, cat_list, coords):
        ax.scatter(x, y, z, s=20, color=color_map.get(c, "black"), alpha=0.8)
        ax.text(x + 0.02, y + 0.02, z + 0.02, w, fontsize=6, alpha=0.9)

    ax.set_title("Emotion Embeddings PCA (overall, 3D)")
    ax.set_xlabel("PC1")
    ax.set_ylabel("PC2")
    ax.set_zlabel("PC3")

    # build legend
    handles = []
    for cat in unique_cats:
        handles.append(plt.Line2D([0], [0], marker="o", color="w",
                                  markerfacecolor=color_map[cat], label=cat, markersize=8))
    ax.legend(handles=handles, fontsize=8, loc="best")

    plt.tight_layout()
    png_path = os.path.join(OUT_DIR, "emotion_pca_overall_3d.png")
    plt.savefig(png_path, dpi=200)
    plt.close()

    print(f"[PCA-3D] Saved overall 3D PCA plot -> {png_path}")


def save_category_pcas(words: List[str], X: np.ndarray, categories: Dict[str, str]) -> None:
    """Compute PCA separately for each category and save plots/CSVs.

    This helps you see the internal structure of each emotion group.
    """

    # Build category -> indices mapping
    cat_to_indices: Dict[str, List[int]] = {}
    for idx, w in enumerate(words):
        cat = categories.get(w, "unknown")
        cat_to_indices.setdefault(cat, []).append(idx)

    for cat, indices in cat_to_indices.items():
        if cat == "unknown":
            continue
        if len(indices) < 2:
            # PCA(2) needs at least 2 points
            print(f"[PCA] Skip category '{cat}' (not enough points: {len(indices)})")
            continue

        cat_words = [words[i] for i in indices]
        cat_X = X[indices]

        print(f"[PCA] Category '{cat}': {len(cat_words)} words")
        pca = PCA(n_components=2)
        coords = pca.fit_transform(cat_X)

        # Save CSV
        csv_path = os.path.join(OUT_DIR, f"emotion_pca_{cat}.csv")
        with open(csv_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["word", "pc1", "pc2"])
            for w, (x, y) in zip(cat_words, coords):
                writer.writerow([w, float(x), float(y)])

        print(f"[PCA]   -> CSV saved: {csv_path}")

        # Plot
        plt.figure(figsize=(8, 6))
        for w, (x, y) in zip(cat_words, coords):
            plt.scatter(x, y, s=30, color="tab:blue", alpha=0.8)
            plt.text(x + 0.02, y + 0.02, w, fontsize=7, alpha=0.9)

        plt.title(f"PCA - {cat} emotions")
        plt.xlabel("PC1")
        plt.ylabel("PC2")
        plt.tight_layout()

        png_path = os.path.join(OUT_DIR, f"emotion_pca_{cat}.png")
        plt.savefig(png_path, dpi=200)
        plt.close()

        print(f"[PCA]   -> Plot saved: {png_path}")


def save_category_pcas_3d(words: List[str], X: np.ndarray, categories: Dict[str, str]) -> None:
    """Compute PCA(3D) separately for each category and save 3D plots/CSVs."""

    # Build category -> indices mapping
    cat_to_indices: Dict[str, List[int]] = {}
    for idx, w in enumerate(words):
        cat = categories.get(w, "unknown")
        cat_to_indices.setdefault(cat, []).append(idx)

    for cat, indices in cat_to_indices.items():
        if cat == "unknown":
            continue
        if len(indices) < 3:
            # PCA(3) needs at least 3 points
            print(f"[PCA-3D] Skip category '{cat}' (not enough points: {len(indices)})")
            continue

        cat_words = [words[i] for i in indices]
        cat_X = X[indices]

        print(f"[PCA-3D] Category '{cat}': {len(cat_words)} words")
        pca = PCA(n_components=3)
        coords = pca.fit_transform(cat_X)

        # Save CSV
        csv_path = os.path.join(OUT_DIR, f"emotion_pca_{cat}_3d.csv")
        with open(csv_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["word", "pc1", "pc2", "pc3"])
            for w, (x, y, z) in zip(cat_words, coords):
                writer.writerow([w, float(x), float(y), float(z)])

        print(f"[PCA-3D]   -> CSV saved: {csv_path}")

        # 3D Plot
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111, projection="3d")
        for w, (x, y, z) in zip(cat_words, coords):
            ax.scatter(x, y, z, s=30, color="tab:blue", alpha=0.8)
            ax.text(x + 0.02, y + 0.02, z + 0.02, w, fontsize=7, alpha=0.9)

        ax.set_title(f"PCA 3D - {cat} emotions")
        ax.set_xlabel("PC1")
        ax.set_ylabel("PC2")
        ax.set_zlabel("PC3")
        plt.tight_layout()

        png_path = os.path.join(OUT_DIR, f"emotion_pca_{cat}_3d.png")
        plt.savefig(png_path, dpi=200)
        plt.close()

        print(f"[PCA-3D]   -> 3D Plot saved: {png_path}")


def main() -> None:
    ensure_out_dir()

    categories = build_category_map()
    words, X = load_embeddings(EMBEDDING_PATH)

    print("====================================")
    print(f"Total words in JSON: {len(words)}")
    print(f"Vector dim: {X.shape[1]}")
    print(f"Output dir: {OUT_DIR}")
    print("====================================")

    save_overall_pca(words, X, categories)
    save_category_pcas(words, X, categories)
    save_overall_pca_3d(words, X, categories)
    save_category_pcas_3d(words, X, categories)


if __name__ == "__main__":
    main()